/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGPetApi.h"

#include "SWGModule.h"
#include "SWGModel.h"

#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"

namespace Swagger 
{

SWGPetApi::SWGPetApi() {}

SWGPetApi::~SWGPetApi() {}

SWGPetApi::SWGPetApi(QString host, QString basePath) {
    this->host = host;
    this->basePath = basePath;
}

void SWGPetApi::SetURL(const FString& InUrl)
{
	Url = InUrl;
}

void SWGPetApi::SetAuthCredentials(const FString& InAuthKey, const FString& InAuthValue)
{
	AuthKey = InAuthKey;
	AuthValue = InAuthValue;
}

bool SWGPetApi::IsValid() const
{
	if (Url.IsEmpty())
	{
		UE_LOG(Log, Error, TEXT("SWGPetApi: Endpoint Url is not set, request cannot be performed"));
		return false;
	}

	return true;
}

TSharedRef<IHttpRequest> SWGPetApi::SendRequest(const TCHAR* Path, const TSharedPtr<FJsonObject>& Body) const
{
	TSharedRef<IHttpRequest> HttpRequest = FHttpModule::Get().CreateRequest();
	HttpRequest->SetVerb(TEXT("POST"));
	HttpRequest->SetURL(*FString::Printf(TEXT("%s/%s"), *Url, Path));
	HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));

	if (!AuthKey.IsEmpty())
		HttpRequest->SetHeader(AuthKey, AuthValue);

	FString JsonString;
	auto Writer = TJsonWriterFactory<>::Create(&JsonString);
	FJsonSerializer::Serialize(Body.ToSharedRef(), Writer);

	UE_LOG(Log, Verbose, TEXT("Sending Http request to (%s):\n%s"), *HttpRequest->GetURL(), *JsonString);

	HttpRequest->SetContentAsString(JsonString);
	return HttpRequest;
}

void SWGPetApi::HandleResponse(FHttpResponsePtr HttpResponse, bool bSucceeded, Response& InOutResponse) const
{
	InOutResponse._Success = bSucceeded;

	if (bSucceeded && HttpResponse.IsValid())
	{
		InOutResponse._ResponseCode = (EHttpResponseCodes::Type)HttpResponse->GetResponseCode();
		FString Content = HttpResponse->GetContentAsString();

		UE_LOG(Log, Verbose, TEXT("Received response:: \n%s"), *Content);

		TSharedPtr<FJsonObject> JsonObject;
		auto Reader = TJsonReaderFactory<>::Create(Content);

		if (FJsonSerializer::Deserialize(Reader, JsonObject) && JsonObject.IsValid())
		{
			if (EHttpResponseCodes::IsOk(InOutResponse._ResponseCode))
			{
				if (InOutResponse.FromJson(JsonObject))
					return; //Successfully parsed
			}
			else
			{
				if (InOutResponse.ErrorFromJson(JsonObject))
					return; //Successfully parsed
			}
		}

		UE_LOG(Log, Error, TEXT("Failed to deserialize Http response content:\n%s"), *Content);
		InOutResponse._Success = false;
		return;
	}

	// Assume we failed to reach the server
	InOutResponse._ResponseCode = EHttpResponseCodes::RequestTimeout;
}

bool SWGPetApi::addPet(addPetRequest& Request, const FaddPetDelegate& Delegate /*= FaddPetDelegate()*/) const
{
	if (IsValid() && !Request.IsValid())
		return false;

	auto HttpRequest = SendRequest(TEXT("/Pet"), Request.ToJson());
	HttpRequest->OnProcessRequestComplete().BindRaw(this, &SWGPetApi::OnaddPetResponse, Delegate);
	return HttpRequest->ProcessRequest();
}

void SWGPetApi::OnaddPetResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FaddPetDelegate Delegate) const
{
	addPetResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
}

bool SWGPetApi::deletePet(deletePetRequest& Request, const FdeletePetDelegate& Delegate /*= FdeletePetDelegate()*/) const
{
	if (IsValid() && !Request.IsValid())
		return false;

	auto HttpRequest = SendRequest(TEXT("/Pet"), Request.ToJson());
	HttpRequest->OnProcessRequestComplete().BindRaw(this, &SWGPetApi::OndeletePetResponse, Delegate);
	return HttpRequest->ProcessRequest();
}

void SWGPetApi::OndeletePetResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FdeletePetDelegate Delegate) const
{
	deletePetResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
}

bool SWGPetApi::findPetsByStatus(findPetsByStatusRequest& Request, const FfindPetsByStatusDelegate& Delegate /*= FfindPetsByStatusDelegate()*/) const
{
	if (IsValid() && !Request.IsValid())
		return false;

	auto HttpRequest = SendRequest(TEXT("/Pet"), Request.ToJson());
	HttpRequest->OnProcessRequestComplete().BindRaw(this, &SWGPetApi::OnfindPetsByStatusResponse, Delegate);
	return HttpRequest->ProcessRequest();
}

void SWGPetApi::OnfindPetsByStatusResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FfindPetsByStatusDelegate Delegate) const
{
	findPetsByStatusResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
}

bool SWGPetApi::findPetsByTags(findPetsByTagsRequest& Request, const FfindPetsByTagsDelegate& Delegate /*= FfindPetsByTagsDelegate()*/) const
{
	if (IsValid() && !Request.IsValid())
		return false;

	auto HttpRequest = SendRequest(TEXT("/Pet"), Request.ToJson());
	HttpRequest->OnProcessRequestComplete().BindRaw(this, &SWGPetApi::OnfindPetsByTagsResponse, Delegate);
	return HttpRequest->ProcessRequest();
}

void SWGPetApi::OnfindPetsByTagsResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FfindPetsByTagsDelegate Delegate) const
{
	findPetsByTagsResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
}

bool SWGPetApi::getPetById(getPetByIdRequest& Request, const FgetPetByIdDelegate& Delegate /*= FgetPetByIdDelegate()*/) const
{
	if (IsValid() && !Request.IsValid())
		return false;

	auto HttpRequest = SendRequest(TEXT("/Pet"), Request.ToJson());
	HttpRequest->OnProcessRequestComplete().BindRaw(this, &SWGPetApi::OngetPetByIdResponse, Delegate);
	return HttpRequest->ProcessRequest();
}

void SWGPetApi::OngetPetByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FgetPetByIdDelegate Delegate) const
{
	getPetByIdResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
}

bool SWGPetApi::updatePet(updatePetRequest& Request, const FupdatePetDelegate& Delegate /*= FupdatePetDelegate()*/) const
{
	if (IsValid() && !Request.IsValid())
		return false;

	auto HttpRequest = SendRequest(TEXT("/Pet"), Request.ToJson());
	HttpRequest->OnProcessRequestComplete().BindRaw(this, &SWGPetApi::OnupdatePetResponse, Delegate);
	return HttpRequest->ProcessRequest();
}

void SWGPetApi::OnupdatePetResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FupdatePetDelegate Delegate) const
{
	updatePetResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
}

bool SWGPetApi::updatePetWithForm(updatePetWithFormRequest& Request, const FupdatePetWithFormDelegate& Delegate /*= FupdatePetWithFormDelegate()*/) const
{
	if (IsValid() && !Request.IsValid())
		return false;

	auto HttpRequest = SendRequest(TEXT("/Pet"), Request.ToJson());
	HttpRequest->OnProcessRequestComplete().BindRaw(this, &SWGPetApi::OnupdatePetWithFormResponse, Delegate);
	return HttpRequest->ProcessRequest();
}

void SWGPetApi::OnupdatePetWithFormResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FupdatePetWithFormDelegate Delegate) const
{
	updatePetWithFormResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
}

bool SWGPetApi::uploadFile(uploadFileRequest& Request, const FuploadFileDelegate& Delegate /*= FuploadFileDelegate()*/) const
{
	if (IsValid() && !Request.IsValid())
		return false;

	auto HttpRequest = SendRequest(TEXT("/Pet"), Request.ToJson());
	HttpRequest->OnProcessRequestComplete().BindRaw(this, &SWGPetApi::OnuploadFileResponse, Delegate);
	return HttpRequest->ProcessRequest();
}

void SWGPetApi::OnuploadFileResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FuploadFileDelegate Delegate) const
{
	uploadFileResponse Response;
	HandleResponse(HttpResponse, bSucceeded, Response);
}


}
